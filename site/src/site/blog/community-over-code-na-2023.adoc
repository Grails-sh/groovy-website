= Community Over Code (North America) 2023
Paul King
:revdate: 2023-10-26T17:00:00+00:00
:description: This post looks at the ASF Community Over Code conference in Halifax, Nova Scotia, October 7-10 2023, with a particular focus on the Groovy Track.
:keywords: groovy, asf, apachecon, communityovercode
:draft: true

This year's North American edition of the ASF conference, https://communityovercode.org/[Community Over Code],
featured four in-person days of sessions (October 7-10) at the Halifax Convention Centre.

NOTE: The presentation slides and audio/video (where available) are still being added onto the conference site.
If additional material becomes available, this post will be updated with links to the additional content.

This post gives an update on the conference. It is mostly a focus on the Groovy track,
but there is also material about other tracks and the many other aspects of the conference.
In particular, hopefully, this post gives you some insight into why going to conferences,
and the ASF conferences in particular, can be a rewarding experience. I hope to see you at
a future conference.

== Upon arrival

Before getting into the conference report proper, just a pro-tip for anyone travelling
to conferences from more than a few time-zones away. If you base your knowledge just on viewing
social media, regular speaking at conferences may look like a glamorous life, but without a little
bit of planning, you may see little more than the inside of planes, hotels, and conference rooms.
It pays to allocate some time to seeing the host city/country. If you also get some sun on the
first day you arrive (or first full day after you arrive if arriving at night), it seems to help
with getting over jet lag.
In my case, I took the opportunity to do a bicycle ride East of Halifax mostly along some
cyclist-friendly bike trails.

image:img/HalifaxRideMap.png[]

The route was 90% on trails built upon now disused railroad tracks
which form part of the https://tctrail.ca/[Trans Canada Trail].
It is further broken down into smaller sections including
the https://www.alltrails.com/trail/canada/nova-scotia/shearwater-flyer-trail[Shearwater Flyer Trail],
the https://www.alltrails.com/trail/canada/nova-scotia/salt-marsh-trail[Salt Marsh Trail],
the https://www.alltrails.com/trail/canada/nova-scotia/atlantic-view-trail[Atlantic View Trail],
and the https://www.alltrails.com/trail/canada/nova-scotia/dartmouth-waterfront-trail[Dartmouth Waterfront Trail].
The place I hired the bike from recommended riding to https://parks.novascotia.ca/park/lawrencetown-beach[Lawrencetown Beach], but I went just a little further for good measure.
The views were spectacular. I particularly like some of the autumn color scenery which is seldom seen
where I live.

image:img/HalifaxRideCollage.jpg[]

== The Groovy Track

image:https://photos.apachecon.com/_data/i/upload/2023/10/20/20231020033313-d56c0136-me.jpg[stickers,200,float="right"]

The Groovy track was spread over the first two days of the conference and had ten sessions
as well as a _birds-of-a-feather_ session after the first day.
The sessions typically had mini-themes: Groovy update, for Java developers, Kubernetes and Groovy,
Groovy and Data Science (this year featuring Apache Ignite) and so on.
Here we'll just look at a few highlights of each talk. You are encouraged to peruse
the slides and other content if you want more details.

=== Groovy update

The first two talks covered the state of the Groovy project with also some updates
from the broader Groovy ecosystem.

image:https://photos.apachecon.com/_data/i/upload/2023/10/12/20231012195704-e8e8482f-me.jpg[Paul King,150,float="right"]
The first talk was https://speakerdeck.com/paulk/groovy-roadmap[Groovy and Groovy Ecosystem Update].
This talked about the status of the Groovy project itself as well as some important projects
within the broader Groovy ecosystem.

Some highlights:

* Groovy downloads recently surpassed the 3 billion mark in total and is currently tracking just over
3 million downloads per day on average.
* Groovy already supports classes and scripts but with JEP 445 scripting on the way in Java (preview in JDK21),
Groovy 5 supports additional forms so that JEP 445 code examples will run straight in Groovy (for JDK11+).
+
[source,groovy]
----
def main() {
    println 'Hello world!'
}
----
There are variations that remain strictly JEP 445 compatible (to gain the same bytecode simplifications)
and variations which retain Groovy's extra features like access to the script binding and context.
The `run` method is used instead of the `main` method to gain the traditional Groovy script features.
An added bonus is that Groovy's `@Field` annotation isn't needed to designate fields within JEP 445-like scripts.
Here is another example, this one using Jackson data binding to serialize itself as a JSON file:
+
[source,groovy]
----
@JsonIgnoreProperties(["binding"])
def run() {
    var mapper = new ObjectMapper()
    assert mapper.writeValueAsString(this) == '{"pets":["cat","dog"]}'
}

public pets = ['cat', 'dog']
----
* Groovy added support for "underscore as a placeholder" functionality. This is similar to JEP 443 (preview in JDK21) but Groovy also adds the feature for Closures and multi-assignment expressions.
+
[source,groovy]
----
var (_, y, m, _, _, d) = Calendar.instance
println "Today is $y-${m+1}-$d" // Today is 2023-8-23
----
* An additional `@OperatorRename` AST transform is now available which makes it easier to use
a multitude of libraries with Groovy's operator overloading. This is handy when working with
libraries that might manipulate complex numbers, matrices, or fractions (as per the example below
which uses the Apache Commons Numbers Fraction library).
Previously, you may have forgone using the operator overloading shortcuts,
or you (or someone else) would have possibly written some Groovy specific
extension methods to provide the nicer operator overloading syntactic sugar for a particular library
of interest. Now, such libraries can now easily be used straight out-of-the-box
with the operator overloading feature.
+
[source,groovy]
----
@OperatorRename(plus='add')
def testAddOfTwoFractions() {
    var half = Fraction.of(1, 2)
    var third = Fraction.of(1, 3)
    assert half.add(third) == Fraction.of(5, 6)  // old style still works
    assert half + third == Fraction.of(5, 6)     // fraction '+' operator!
}
----
* Grails 6 was recently released with support for recent versions of Groovy 3.
* Micronaut 4 was recently released with support for recent versions of Groovy 4.
* Geb 7 and several versions of the Spock testing framework also support Groovy 4.
* The latest version of the Deep Netts deep learning library works well when using
Groovy 5 with GraalVM.
* The latest version of Apache Ignite works well with Groovy 5 when scaling up
your distributed data, distributed compute, and distributed data science applications.

The second talk was https://speakerdeck.com/paulk/groovy-today[Why use Groovy in 2023]?
This discussed the features that make Groovy a compelling language choice even given the
wonderful progress being made in other languages within the JDK ecosystem.

Some highlights:

* Groovy is compelling if you need its dynamic features like runtime metaprogramming,
lifecycle hooks, and dynamic builders.
* Groovy also offers features like ranges, default parameters, named arguments,
command chains, operator overloading, extensible tooling including an
extensible type checker.
* As well as its own native features, Groovy 5 provides about 2000 extension
methods for around 150 Java classes.
* Traits provide similar functionality to default methods in interfaces but rather
than just tackling the problem of API evolution, traits are a more ambitious and
powerful OO feature. Groovy offers stateful traits, more powerful method selection
options, offers trait application at runtime (dynamic traits) and supports the
stackable traits pattern like Scala.
* Groovy's Closure abstraction offers several powerful mechanisms over and above
what lambdas offer including memoization and tail call recursion handling.
You can write factorial in a more natural recursive form (avoiding an explicitly
imperative algorithm) and not suffer from stack overflow issues.
You can write recursive fibonacci algorithms that take milliseconds
to execute rather than the trillions of years a na√Øve recursive algorithm would take.
* AST transforms (based around annotations) and
macro methods (which are similar but look like methods calls)
allow a declarative style of programming where a few lines of code
can be replaced with hundreds or thousands of lines of equivalent code.
The generated code follows best practice and is much less error-prone.
Groovy 5 has 80+ AST transforms.
* Language integrated queries allow a SQL-like style for querying data.
+
[source,groovy]
----
GQ {
    from fruit in ['Apple', 'Apricot', 'Banana', 'Cantaloupe']
    groupby fruit[0] as firstChar
    select firstChar, list(fruit.toUpperCase()) as fruit_list
}
----
which yields:
+
----
+-----------+------------------+
| firstChar | fruit_list       |
+-----------+------------------+
| A         | [APPLE, APRICOT] |
| B         | [BANANA]         |
| C         | [CANTALOUPE]     |
+-----------+------------------+
----
* While we like, many of the exciting changes for switch expressions coming along with
recent Java versions, Groovy still provides numerous additional options (for JDK8+):
image:img/Groovy2023Switch.png[Groovy switch expressions,border="1"]
* Groovy gives you the choice of emulated records for JDK8+
or native records for JDK16+ with many record enhancements:
image:img/Groovy2023Records.png[Groovy records]
Over and above the built-in enhancements, record development is made
easier by Groovy's AST transforms. The slides have examples of combining
records with the following AST transforms:
`@PropertyOptions`, `@ToString`, `@Memoized`, `@Builder`,
`@Requires`, `@Sortable`, `@Newify`, and `@OperatorRename`.
But of course, you aren't limited to just that list.

=== Groovy for Java developers

The next two talks were aimed at Java developers who wanted to understand how
they could use Groovy for their development or testing needs.

Groovy for Java Developers

The next talk was
https://speakerdeck.com/paulk/property-based-testing[Testing your Java with Groovy, Spock, JUnit5, Jacoco, Jqwik and Pitest].

=== Kubernetes and Groovy

The next mini-theme in the Groovy track was Kubernetes and Groovy.
image:https://photos.apachecon.com/_data/i/upload/2023/10/12/20231012200925-e882ed51-me.jpg[Jorge Aguilera,200,float="right"]

The first talk was by https://jvm.social/@jorge[Jorge Aguilera]: _It works on my cluster. Deploying a groovy kubernetes application to Okteto._
https://communityovercode.files.wordpress.com/2023/10/sat_groovy_it_works_on_my_cluster-jorge.pdf[Slides]

In this talk, Jorge showed a
https://groovy-lang.org/[Groovy]
https://micronaut.io/[Micronaut]
https://kubernetes.io/[Kubernetes] (k8s) application deployed in the cloud.
It was deployed to the Okteto platform, so that in fact most of the k8s details were taken
care of by the platform.

The sample application was a simple solution to the
https://en.wikipedia.org/wiki/Collatz_conjecture[Collatz conjecture].
I remember studying this back in my Uni days but had forgotten the details.
Basically, given a starting number, one of two calculations is performed,
depending on whether the current number is even.
Odd numbers are multiplied by 3 and then 1 is added, even numbers are divided by 2.
This is stopped if the result becomes the number 1, but otherwise continues.
The conjecture is that eventually, the calculation terminates, i.e. it always eventually equals 1.

Of interest is the number of cycles needed to get to 1.
Here is an algorithm that returns the number of cycles:

[source,groovy]
----
class Collatz {
  static long getAt(BigInteger n) {
    var result = n
    var count = 0L
    while (result != 1G) {
      if (result % 2G == 0G) {
        result /= 2G
      } else {
        result *= 3G
        result++
      }
      count++
    }
    count
  }
}
----

We used a static `getAt` method to give us a neat shorthand for getting the result.
We can test out some of the example sequences mentioned in the https://en.wikipedia.org/wiki/Collatz_conjecture[Wikipedia page]:

[source,groovy]
----
assert Collatz[12] == 9
assert Collatz[19] == 20
assert Collatz[27] == 111
----

Now, to create our microservice based around this algorithm.
We can create a fully working (but skeleton) project for Micronaut in a number
of ways. Here, is what is needed from the command-line:

[source]
----
mn create-app \
    --features kubernetes \
    --features postgres \
    --features jdbc-data \
    --lang groovy collatz
----

We've shown some example features you might want to use.
You could add further features depending on your application's needs.

We can change the skeleton controller to have our desired functionality:

[source,groovy]
----
@Controller
  ...
  @Get('{n}')
  Map index(BigInteger n) {
    [n: n, count: Collatz[n]]
  }
...
----

Jorge then went on to explain the k8s configuration details and gave a demonstration
deploying the application.

Jorge also presented the next talk: https://communityovercode.files.wordpress.com/2023/10/sat_groovy_let_groovy_operate_your_cluster-jorge.pdf[Let Groovy operate your k8s cluster].
This dived into more k8s details. He showed how to write a swagger-operator in Groovy
which removed the need for tedious manual steps when deploying k8s applications.
The operator monitors our services, rewrites the configmap if needed and restarts the pod.

The operator itself was written in https://micronaut.io/[Micronaut]:

[source,groovy]
----
@Operator(
    informer = @Informer(
        apiType = V1Swagger,
        apiListType = V1SwaggerList,
        apiGroup = V1SwaggerWrapper.GROUP,
        resourcePlural = V1SwaggerWrapper.PLURAL,
        resyncCheckPeriod = 10000L)
)
class SwaggerOperator implements ResourceReconciler<V1Swagger>{
}
----

=== Apache Groovy and Apache Ignite

The next mini-theme was Groovy and Data Science. Groovy has been described
as the Python equivalent for the JVM and Groovy works well with many of the ASF
frameworks and technologies related to data science and big data in general.
This year the conference had a particular focus on scaling up data science,
data and compute applications using https://ignite.apache.org/[Apache Ignite].

The first talk was https://speakerdeck.com/paulk/whisky-clustering-groovy-ignite[Whisky Clustering with Apache Groovy and Apache Ignite]

As a side note, it is rumoured that additional extensive research on this topic may (or may not)
have been held in conjunction with the conference. Only because the conference was in (Nova) Scotia no doubt!
image:img/HalifaxWhisky.png[Citadel]

image:https://photos.apachecon.com/_data/i/upload/2023/10/13/20231013192401-65a58458-cu_s9999x410.jpg[Jeremy Meyer,200,float="right"]
The second talk was by https://www.linkedin.com/in/jeremy-s-meyer/[Jeremy Meyer]:
https://drive.google.com/file/d/1vjDkFmG9zz9y7yDY10ru9tya7KidJsqG/view?usp=sharing[Scalable Distributed Computing with Groovy Using Apache Ignite]

=== Miscellaneous

GORM Data Services

Open Source Software and You

== But wait, there's more...

image:img/HalifaxCitadel.png[Citadel]

image:img/HalifaxConferenceOverall.png[conference]

== Back home

When you return from a trip, make sure to catch up with family and friends.
In my case, this involved a weekend away at the beach.

image:img/MermaidBeach.jpg[Mermaid Beach]

== Other information

Other trip reports for the Halifax Community over Code conference 2023:

* https://www.linkedin.com/pulse/code-connections-collaboration-unpacking-community-over-atita-arora-b0gfe/[A review by Atita Arora].

See also:

* https://photos.apachecon.com/index.php?/category/37[Additional photos] grouped roughly into days and sessions within each day.
* https://communityovercode.org/schedule/[The official schedule] includes all tracks and will include
links to the slides of the talks if/when available.
* Details for https://eu.communityovercode.org/[Community over Code EU] next year.